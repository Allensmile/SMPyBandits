Info: numba.jit seems to be available.
For depth = 1 ...

Starting to explore every transitions up-to depth 1 for this root state:
    State : M = 1, K = 3 and t = 0, depth = 0.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[0 0 0]] =: N
[[0 0 0]] =: Ntilde

    Using these policies:
  - Player #0/1 uses Selfish_UCB_Ubar (which is <function Selfish_UCB_Ubar at 0x7f37f79cc9d8>)...
    Using these arms:
  - Arm #0/3 has mean mu_1 ...
  - Arm #1/3 has mean mu_2 ...
  - Arm #2/3 has mean mu_3 ...

For depth = 1, exploring from this node :
    State : M = 1, K = 3 and t = 0, depth = 0.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[0 0 0]] =: N
[[0 0 0]] =: Ntilde

coin_flips = (0, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = (-mu_1 + 1)*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (0, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_3*(-mu_1 + 1)*(-mu_2 + 1)
coin_flips = (0, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*(-mu_1 + 1)*(-mu_3 + 1)
coin_flips = (0, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*mu_3*(-mu_1 + 1)
coin_flips = (1, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (1, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_3*(-mu_2 + 1)
coin_flips = (1, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*(-mu_3 + 1)
coin_flips = (1, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*mu_3
coin_flips = (0, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = (-mu_1 + 1)*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (0, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_3*(-mu_1 + 1)*(-mu_2 + 1)
coin_flips = (0, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*(-mu_1 + 1)*(-mu_3 + 1)
coin_flips = (0, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*mu_3*(-mu_1 + 1)
coin_flips = (1, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (1, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_3*(-mu_2 + 1)
coin_flips = (1, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*(-mu_3 + 1)
coin_flips = (1, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*mu_3
coin_flips = (0, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = (-mu_1 + 1)*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (0, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_3*(-mu_1 + 1)*(-mu_2 + 1)
coin_flips = (0, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*(-mu_1 + 1)*(-mu_3 + 1)
coin_flips = (0, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_2*mu_3*(-mu_1 + 1)
coin_flips = (1, 0, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*(-mu_2 + 1)*(-mu_3 + 1)
coin_flips = (1, 0, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_3*(-mu_2 + 1)
coin_flips = (1, 1, 0)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*(-mu_3 + 1)
coin_flips = (1, 1, 1)
self.mus = [mu_1, mu_2, mu_3]
proba_of_this_coin_flip = mu_1*mu_2*mu_3
  we saw 6 different states...



There are 6 unique leafs for depth 1...

 Leaf with probability = mu_1/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 0.  0.  1.]] =: S
[[ 0.  0.  1.]] =: Stilde
[[0 0 1]] =: N
[[0 0 1]] =: Ntilde


 Leaf with probability = mu_1/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 0.  1.  0.]] =: S
[[ 0.  1.  0.]] =: Stilde
[[0 1 0]] =: N
[[0 1 0]] =: Ntilde


 Leaf with probability = -(mu_1 - 1)/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[0 1 0]] =: N
[[0 1 0]] =: Ntilde


 Leaf with probability = -(mu_1 - 1)/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[1 0 0]] =: N
[[1 0 0]] =: Ntilde


 Leaf with probability = mu_1/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 1.  0.  0.]] =: S
[[ 1.  0.  0.]] =: Stilde
[[1 0 0]] =: N
[[1 0 0]] =: Ntilde


 Leaf with probability = -(mu_1 - 1)/3:
    State : M = 1, K = 3 and t = 1, depth = 0.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[0 0 1]] =: N
[[0 0 1]] =: Ntilde


Done for exploring every transitions up-to depth 1 for this root state:
    State : M = 1, K = 3 and t = 0, depth = 1.
[[ 0.  0.  0.]] =: S
[[ 0.  0.  0.]] =: Stilde
[[0 0 0]] =: N
[[0 0 0]] =: Ntilde

    Using these policies:
  - Player #0/1 uses Selfish_UCB_Ubar (which is <function Selfish_UCB_Ubar at 0x7f37f79cc9d8>)...
    Using these arms:
  - Arm #0/3 has mean mu_1 ...
  - Arm #1/3 has mean mu_2 ...
  - Arm #2/3 has mean mu_3 ...

There were 6 unique leafs for depth 1...


For depth 1, 0 leafs were found to be absorbing, and the probability of reaching any absorbing leaf is 0...

Creating a dot graph from the state...
Saving the dot graph to 'plots/trees/Tree_exploration_K=3_M=1_depth=1__Selfish_UCB_Ubar.svg'...


[Enter] to continue...